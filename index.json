[{"content":" Sage is a compiled language for anything from OS-dev to the web!\nWatch the video above about compilers, and how Sage works!\n","date":"9 September 2024","externalUrl":null,"permalink":"/sage-website/","section":"","summary":"","title":"","type":"page"},{"content":"","date":"9 September 2024","externalUrl":null,"permalink":"/sage-website/series/documentation/","section":"Series","summary":"","title":"Documentation","type":"series"},{"content":"","date":"9 September 2024","externalUrl":null,"permalink":"/sage-website/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":" Let Bindings # Variables are bound in Sage using the let keyword. You can optionally include the type of the variable to be typechecked against.\n// Create a variable named a, with the value 5 let a = 5; let b = {x=5, y=6}; let c: (Int, Int, Int) = (1, 2, 3); // Optionally include the type println(a); println(b); println(c); Output: 5 {x=5, y=6} (1, 2, 3) Mutability # You can make a variable as mutable with the mut keyword. If you try to assign to a variable that isn\u0026rsquo;t mutable, the compiler will yell at you!\nlet mut a = 5; println(a); a = 6; println(a); Output: 5 6 Destructured Let Bindings # In many instances, users want to be able to decompose the attributes of structures or tuples into variables.\nlet (a, {mut x, y}) = (1, {x=5, y=6}); println(a, \u0026#34;, \u0026#34;, x, \u0026#34;, \u0026#34;, y); x = 999; println(a, \u0026#34;, \u0026#34;, x, \u0026#34;, \u0026#34;, y); Output: 1, 5, 6 1, 999, 6 Variables And Scope # Variables are not captured by functions \u0026ndash; functions mainly act as procedures. Additionally, variables may not be referenced before their definition.\nprintln(a); let a = 5; Output:\nerror: Error at text-box:0:8:8 ┌─ text-box:1:9 │ 1 │ println(a); │ ^ LIR error: symbol a not defined ","date":"9 September 2024","externalUrl":null,"permalink":"/sage-website/docs/variables/","section":"Documentation","summary":"","title":"Variables And Mutability","type":"docs"},{"content":" Writing And Executing A Sage Program # Install Sage: First, head to the installation page to get Sage on your machine! Once you have Sage installed, you can start writing Sage code!\nBegin by creating a new folder for your Sage project:\n$ mkdir hello-world $ cd hello-world Create a Sage program with the .sg file extension:\n$ echo \u0026#39;println(\u0026#34;Hello world!\u0026#34;);\u0026#39; \u0026gt; main.sg Then, compile and run your program!\n$ # Compile and interpret the VM code $ sage main.sg $ # Compile and translate the VM code to C $ sage main.sg -tc $ gcc out.c -O3 -o main # Compile the generated C code CLI Interface # For more information about Sage\u0026rsquo;s CLI, you can run sage -h:\n$ sage -h █████ ██████ ███████ ██████ `-. _.-\u0026#39; ███░░ ░░░░░███ ███░░███ ███░░███ \\ `, .\u0026#39;/.\u0026#39; ░░█████ ███████ ░███ ░███░███████ \\`.`. :.-\u0026#39;.-= .-\u0026#39;/ ░░░░███ ███░░███ ░███ ░███░███░░░ `-.:/o .\u0026#39;-\u0026#39;/ .\u0026#39; ██████ ░░████████░░███████░░██████ o\\o / ._/.\u0026#39; ░░░░░░ ░░░░░░░░ ░░░░░███ ░░░░░░ \\| /o|\\`. ███ ░███ |\u0026#39;o `.`.\u0026#39;. ░░██████ `--\u0026#39; ░░░░░░ Usage: sage [OPTIONS] \u0026lt;INPUT\u0026gt; Arguments: \u0026lt;INPUT\u0026gt; The input file to compiler Options: -o, --output \u0026lt;OUTPUT\u0026gt; The file to write the output of the compiler to [default: out] -s \u0026lt;SOURCE_TYPE\u0026gt; The source language to compile [default: sage] [possible values: sage, low-ir, core-asm, std-asm, core-vm, std-vm] -t \u0026lt;TARGET_TYPE\u0026gt; The target language to compile to [default: run] [possible values: run, core-asm, std-asm, core-vm, std-vm, c] -c, --call-stack-size \u0026lt;CALL_STACK_SIZE\u0026gt; The number of cells allocated for the call stack [default: 8192] -l, --log-level \u0026lt;LOG_LEVEL\u0026gt; The log level to use [default: off] [possible values: error, warn, info, debug, trace, off] -d, --debug \u0026lt;DEBUG\u0026gt; The symbol to debug (if any exists). This will also enable debug logging -h, --help Print help (see more with \u0026#39;--help\u0026#39;) -V, --version Print version Now that you have Sage on your machine, let\u0026rsquo;s dive into the language itself and write some neat programs!\n","date":"9 September 2024","externalUrl":null,"permalink":"/sage-website/docs/getting-started/","section":"Documentation","summary":"","title":"Getting Started","type":"docs"},{"content":" Table Of Contents # Overview Community Code Examples And Syntax Learn More About The Author Overview # Sage is a small programming language with a unique blend of features from Rust and Python. It\u0026rsquo;s statically typed, portable, and easy-to-use.\nWhy Sage? The Sage programming language was created as an alternative to languages like C, but with a nicer type system and development experience. Users are able to print out modules, functions, types. enums are more powerful, and can be used for better error management. Immutability is by default, with enforced typechecking and mutability rules. Sage also includes a module system for organizing code. Sage can be used for anything from operating systems development, to web development.\nCommunity # Join the Discord server to chat about Sage! Let us know if you have any thoughts or comments about the language!\nCode Examples And Syntax # Without further ado, let\u0026rsquo;s see what Sage\u0026rsquo;s syntax looks like!\nHello World! # Sage code is like Python \u0026ndash; you can just start writing without a main function!\nTo print something, just use print on whatever arguments you want!\nprintln(\u0026#34;Hello world!\u0026#34;); Output: Hello world! print also works on custom data structures.\nprintln(\u0026#34;Hello! \u0026#34;, {x = 5, y = 6, z = 7}, \u0026#34; \u0026#34;, [1, 2, 3, 4]); Output: Hello! {x=5, y=6, z=7} [1, 2, 3, 4] Functions # You can write functions in Sage using the fun keyword. Here\u0026rsquo;s an example of the gcd function implemented in Sage!\n// Calculate the greatest common divisor of two numbers // using Euclid\u0026#39;s algorithm fun gcd(a: Int, b: Int): Int { if b == 0 { return a; } return gcd(b, a % b); } println(gcd(12, 15)); Output: 3 Standard Library Imports # You can get started with the standard library by importing some modules!\n// Import some stuff! from std.fallible import Option, Result, panic; from std.collections import Vec, HashMap, List; from std.io import *; // Create a vector and push stuff onto it! let mut v = Vec.make\u0026lt;Int\u0026gt;(); v.push(1); v.push(2); v.push(3); v.print(); Output: [1, 2, 3] Structs And Methods # Here\u0026rsquo;s how we can define custom struct types, and imbue them with methods we can call!\n// Create a structure named Point, with members `x` and `y` struct Point { x: Int, y: Int } impl Point { // A method for creating a new point fun new(x: Int, y: Int): Point { return {x = x, y = y}; } // Shift this point by a given amount in the X // and Y directions fun translate(\u0026amp;mut self, dx: Int, dy: Int) { self.x += dx; self.y += dy; } } // Create a mutable point at (4, 5) let mut p = Point.new(4, 5); // Print the point println(p); // Translate the X by -5, and the Y by 10 p.translate(-5, 10); // Print the translated point println(p); Output: {x=4, y=5} {x=-1, y=15} Sum Types # Sage supports generic algebraic datatypes, and typechecks them with structural equality! This lets you define types linked-lists in a much more canonical way than most languages.\nenum List\u0026lt;Elem\u0026gt; { Cons { data: Elem, next: \u0026amp;List\u0026lt;Elem\u0026gt; }, Nil } let l = List\u0026lt;Int\u0026gt; of Cons { data=5, next=new List\u0026lt;Int\u0026gt; of Nil }; match l { of Cons {data, next} =\u0026gt; { println(\u0026#34;l is cons with data=\u0026#34;, data, \u0026#34; and next=\u0026#34;, next); }, of Nil =\u0026gt; { println(\u0026#34;Got nil\u0026#34;); } } Output: l is cons with data=5 and next=\u0026amp;(38999) Const-Generics # Sage\u0026rsquo;s typesystem is also equipped to handle types with const parameters. This can come in handy for many use-cases. For example, this feature allows you to typecheck matrix dimensions in matrix multiplications!\n// Define a constant sized matrix with a generic element type // and parameterized width and height. struct Matrix\u0026lt;T, const Rows: Int, const Cols: Int\u0026gt; { arr: [[T * Cols] * Rows] } // Add some methods to our matrix impl Matrix\u0026lt;T, Rows, Cols\u0026gt; { // Create a new matrix populated with initial values fun new(x: T): Matrix\u0026lt;T, Rows, Cols\u0026gt; { return {arr=[[x] * Cols] * Rows}; } // Get a value from a matrix fun get(\u0026amp;self, row: Int, col: Int): \u0026amp;T { return \u0026amp;self.arr[row][col]; } // Multiply with another matrix fun mul\u0026lt;const NewCols: Int\u0026gt;( \u0026amp;self, other: \u0026amp;Matrix\u0026lt;T, Cols, NewCols\u0026gt;, zero: T, add: fun(T, T) -\u0026gt; T, mul: fun(T, T) -\u0026gt; T ): Matrix\u0026lt;T, Rows, NewCols\u0026gt; { let mut result = Matrix.new\u0026lt;T, Rows, NewCols\u0026gt;(zero); // Perform the actual matrix multiplication on the rows and cols // This uses the naive algorithm for matrix multiplication for let mut j=0; j\u0026lt;NewCols; j+=1; { for let mut i=0; i\u0026lt;Rows; i+=1; { let mut sum = zero; for let mut k=0; k\u0026lt;Cols; k+=1; { sum = add(sum, mul(self.arr[i][k], other.arr[k][j])); } result.arr[i][j] = sum; } } result } } Virtual Machine Instruction Set # History: What makes Sage special is not its frontend, however, but its backend. The backend was originally born out of a SIMD-extended Brainf$%\u0026amp;@ compiler. Sage\u0026rsquo;s instruction set is tiny enough to port in an afternoon, but efficient enough to compile high level code efficiently. The virtual machine is a simple Turing-tape based architecture, not a stack or register based virtual machine. This is one of the contributing factors to Sage\u0026rsquo;s portability.\nInstruction C Equivalent while while (reg[0]) { if if (reg[0]) { else } else { end } set N_0, N_1, ..., N_X reg[0] = N_0; reg[1] = N_1; ... reg[x] = N_X; call funs[reg[0]](); ret return; load N memcpy(reg, tape_ptr, N * sizeof(cell)); store N memcpy(tape_ptr, reg, N * sizeof(cell)); move N tape_ptr += N; where reg[0].p = tape_ptr; deref push(tape_ptr); tape_ptr = *tape_ptr; refer tape_ptr = pop(); index N for (int i=0; i\u0026lt;N; i++) reg[i].p += tape_ptr-\u0026gt;i; offset O, N for (int i=0; i\u0026lt;N; i++) reg[i].p += O; swap N for (int i=0; i\u0026lt;N; i++) swap(reg + i, tape_ptr + i); add N for (int i=0; i\u0026lt;N; i++) reg[i].i += tape_ptr[i].i; sub N for (int i=0; i\u0026lt;N; i++) reg[i].i -= tape_ptr[i].i; mul N for (int i=0; i\u0026lt;N; i++) reg[i].i *= tape_ptr[i].i; div N for (int i=0; i\u0026lt;N; i++) reg[i].i /= tape_ptr[i].i; rem N for (int i=0; i\u0026lt;N; i++) reg[i].i %= tape_ptr[i].i; or N for (int i=0; i\u0026lt;N; i++) reg[i].i ||= tape_ptr[i].i; and N for (int i=0; i\u0026lt;N; i++) reg[i].i \u0026amp;\u0026amp;= tape_ptr[i].i; not N for (int i=0; i\u0026lt;N; i++) reg[i].i = !reg[i].i; bitand N for (int i=0; i\u0026lt;N; i++) reg[i].i \u0026amp;= tape_ptr[i].i; bitor N for (int i=0; i\u0026lt;N; i++) reg[i].i |= tape_ptr[i].i; bitxor N for (int i=0; i\u0026lt;N; i++) reg[i].i ^= tape_ptr[i].i; lsh N for (int i=0; i\u0026lt;N; i++) reg[i].i \u0026lt;\u0026lt;= tape_ptr[i].i; l-rsh N for (int i=0; i\u0026lt;N; i++) reg[i].i = (uint64_t)reg[i].i \u0026gt;\u0026gt; tape_ptr[i].i; a-rsh N for (int i=0; i\u0026lt;N; i++) reg[i].i \u0026gt;\u0026gt;= tape_ptr[i].i; gez N for (int i=0; i\u0026lt;N; i++) reg[i].i = reg[i].i \u0026gt;= 0; Learn More # Documentation: First, take a look at the docs! You can read my blog post (~20 minute read) about the programming language to learn more about the implementation!\nHere\u0026rsquo;s a 23 minute YouTube video that covers how compilers work, and delves into Sage!\nJoin the Discord server to chat about Sage!\nHow do I contribute? # If you want to contribute, you can open an issue or a pull request. Adding backends for other architectures is a great way to contribute! We also need a VSCode syntax highlighting extension!\nAbout The Author # I\u0026rsquo;m a computer science PhD student at the University of Tennessee, Knoxville🍊. Rust is my favorite language, and I\u0026rsquo;ve written many other compilers. This is the last project I started as a teenager, and I was the only author to touch any of the code up to version v0.0.2-alpha (12/25/2023)!\n","date":"8 September 2024","externalUrl":null,"permalink":"/sage-website/docs/about/","section":"Documentation","summary":"","title":"About The Sage Programming Language","type":"docs"},{"content":" Start here: read the Getting Started page! ","date":"8 September 2024","externalUrl":null,"permalink":"/sage-website/docs/","section":"Documentation","summary":"","title":"Documentation","type":"docs"},{"content":" Pre-installation: You\u0026rsquo;ll the Rust programming language to build the compiler from source. If you\u0026rsquo;re on Windows, then you\u0026rsquo;ll need to download and install the MSVC toolchain prior to building everything. Once you\u0026rsquo;ve installed Rust, and you can use the cargo package manager, run the following to install Sage.\nInstall With Cargo # $ cargo install --git https://github.com/adam-mcdaniel/sage Clone And Build # You can also download the compiler from GitHub manually and build it.\n$ git clone https://github.com/adam-mcdaniel/sage $ cd sage $ # Just build the compiler from source, don\u0026#39;t install it: $ cargo build --release # The `sage` exe will be in `target/release` $ # Install it from this github clone: $ cargo install -f --path . Post-Install # Once you\u0026rsquo;ve installed everything, you can get started with Sage by running the sage command! Use sage -h to see some basic help on the CLI!\nWhat next? Check out the documentation, and take a look at the compiler playground for some example programs! ","date":"8 September 2024","externalUrl":null,"permalink":"/sage-website/installs/install/","section":"Installs","summary":"","title":"Install The Sage Programming Language","type":"installs"},{"content":"","date":"8 September 2024","externalUrl":null,"permalink":"/sage-website/installs/","section":"Installs","summary":"","title":"Installs","type":"installs"},{"content":"Here\u0026rsquo;s a compiler playground to experiment with the Sage programming language in the web! Feel free to edit the code and run your own programs!\nClick the compile button to compile and run the code. This will show the output in the lower pane.\nTo change the example program, use the drop down at the top of the playground. You can choose from a variety of examples to see the program features. You can also view the internal stages of compilation with the dropdown next to the compile button.\n","date":"8 September 2024","externalUrl":null,"permalink":"/sage-website/playgrounds/playground/","section":"Playgrounds","summary":"","title":"Experiment With Sage In The Web","type":"playgrounds"},{"content":"","date":"8 September 2024","externalUrl":null,"permalink":"/sage-website/playgrounds/","section":"Playgrounds","summary":"","title":"Playgrounds","type":"playgrounds"},{"content":"","externalUrl":null,"permalink":"/sage-website/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/sage-website/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/sage-website/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]