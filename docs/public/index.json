
[{"content":" Sage is a compiled language for anything from OS-dev to the web!\nWatch the video above about compilers and how Sage works!\n","date":"10 September 2024","externalUrl":null,"permalink":"/sage-website/","section":"","summary":"","title":"","type":"page"},{"content":" Defining Foreign Functions In Sage # Sage allows you to call functions from target backends, such as C, using the extern keyword. This keyword tells the compiler to expect the symbol to be provided by the target backend.\n// Signatures for the C functions `getchar` and `putchar`. extern fun getchar(): Char; extern fun putchar(ch: Char); // A signature for a function that wraps the C function `memcpy`. extern fun memcpy(dst: \u0026amp;mut Int, src: \u0026amp;Int, cells: Int); let a = [1, 2, 3, 4, 5]; let mut b = [0, 0, 0, 0, 0]; memcpy(\u0026amp;mut b, \u0026amp;a, 5); About Sage: The web-demo of Sage provides only two extern functions in the backend: alert and eval. You can use eval to run arbitrary JavaScript code, so it\u0026rsquo;s still complete to interoperate with other code in the browser. ","date":"10 September 2024","externalUrl":null,"permalink":"/sage-website/docs/calling-c-code/","section":"Documentation","summary":"","title":"Calling C Code","type":"docs"},{"content":"","date":"10 September 2024","externalUrl":null,"permalink":"/sage-website/series/documentation/","section":"Series","summary":"","title":"Documentation","type":"series"},{"content":"","date":"10 September 2024","externalUrl":null,"permalink":"/sage-website/series/","section":"Series","summary":"","title":"Series","type":"series"},{"content":" Associated Constants # Types can have associated constants, which allow users to access the constant through the . operator. Associated constants are defined with the const keyword in an impl block.\nstruct Point { x: Int, y: Int, } // The `impl` block allows us to define methods and constants // which are associated with the given type. impl Point { const ORIGIN = {x=0, y=0}; } let p = Point.ORIGIN; println(p); Output: {x=0, y=0} Associated Functions # Associated functions are similar to associated constants, but they are functions instead of values. They are defined with the fun keyword in an impl block.\nstruct Point { x: Int, y: Int, } impl Point { const ORIGIN = {x=0, y=0}; // A constructor takes no `self` parameter. // It is a static function that returns a new // instance of the type. fun new(x: Int, y: Int): Point { return {x, y}; } } let p = Point.new(4, 5); println(p); Output: {x=4, y=5} These functions don\u0026rsquo;t take an instance of Point, but they\u0026rsquo;re still accessed through the Point type. This is useful for creating constructors or other static functions that are associated with the type.\nMethods # This same mechanism allows us to define methods for our types. Methods are associated functions that allow us to mutate the underlying data, or perform operations on it without mutating it.\n// A function for computing the absolute value of an integer fun abs(x: Int): Int { if x \u0026lt; 0 { return -x; } return x; } struct Point { x: Int, y: Int, } impl Point { const ORIGIN = {x=0, y=0}; // A constructor takes no `self` parameter. // It is a static function that returns a new // instance of the type. fun new(x: Int, y: Int): Point { return {x, y}; } // A method takes a `self` parameter. // This method mutates the `Point` instance, // so it takes a mutable reference. fun translate(\u0026amp;mut self, dx: Int, dy: Int) { self.x += dx; self.y += dy; } // Calculate the manhattan distance between two points // This method does not mutate the `Point` instance, // so it takes an immutable reference. fun manhattan_distance(\u0026amp;self, other: \u0026amp;Point): Int { return abs(self.x - other.x) + abs(self.y - other.y); } // You can also define methods that don\u0026#39;t take // a reference to `self` fun print(self) { println(\u0026#34;{x=\u0026#34;, self.x, \u0026#34;, y=\u0026#34;, self.y, \u0026#34;}\u0026#34;); } } // Create a new point, translate it, and print it let mut p = Point.new(4, 5); println(p); p.translate(-5, 10); p.print(); // Print the point\u0026#39;s distance to the origin let p2 = Point.ORIGIN; println(\u0026#34;Distance: \u0026#34;, p.manhattan_distance(\u0026amp;p2)); Output: {x=4, y=5} {x=-1, y=15} Distance: 16 ","date":"10 September 2024","externalUrl":null,"permalink":"/sage-website/docs/associated-constants/","section":"Documentation","summary":"","title":"Methods And Associated Constants","type":"docs"},{"content":" If Statements # If statements in Sage are similar to those in other languages. The syntax is as follows:\nlet a = 5; if a == 5 { println(\u0026#34;a is 5!\u0026#34;); } else { println(\u0026#34;a is not 5!\u0026#34;); } Output: a is 5! You can also use else if to chain multiple conditions together.\nlet a = 6; if a == 5 { println(\u0026#34;a is 5!\u0026#34;); } else if a == 6 { println(\u0026#34;a is 6!\u0026#34;); } else { println(\u0026#34;a is not 5 or 6!\u0026#34;); } Output: a is 6! Loops # Sage has two types of loops: for and while.\nFor Loops # For loops in Sage are similar to those in C \u0026ndash; they have an initialization, a condition, and an increment.\nfor let mut i=0; i\u0026lt;5; i+=1; { println(i); } Output: 0 1 2 3 4 While Loops # While loops are also similar to those in C.\nlet mut i = 0; while i \u0026lt; 5 { println(i); i += 1; } Output: 0 1 2 3 4 Break and Continue # break and continue are not supported, but might be added in future releases.\n","date":"10 September 2024","externalUrl":null,"permalink":"/sage-website/docs/control-flow/","section":"Documentation","summary":"","title":"Control Flow","type":"docs"},{"content":" Single Line Comments # Single line comments are created with //. Anything after // on a line is ignored by the compiler.\n// This is a comment let a = 5; // This is another comment println(a); // This is a third comment Output: 5 Multi Line Comments # Multi line comments are created with /* and */. Anything between /* and */ is ignored by the compiler.\n/* This is a comment that spans multiple lines */ let a = 5; println(a); Output: 5 Nested Comments # Sage allows nested comments, which can be useful for commenting out large blocks of code.\n/* This is a comment /* that is nested */ // This is a nested single line comment in a block comment and spans multiple lines */ let a = 5; println(a); Output: 5 ","date":"10 September 2024","externalUrl":null,"permalink":"/sage-website/docs/comments/","section":"Documentation","summary":"","title":"Comments","type":"docs"},{"content":"In Sage, functions are declared with the fun keyword.\nfun add(a: Int, b: Int): Int { return a + b; } println(add(2, 3)); Output: 5 Alternate Syntax # Functions may also be defined with a single expression and the = operator.\nfun add(a: Int, b: Int): Int = a + b; println(add(2, 3)); Output: 5 Function Types # Functions can be passed as arguments to other functions. The type of a function is written as fun(T1, T2, ..., Tn) -\u0026gt; T.\n// Define `f` as a function that takes two ints and // returns another int. // Call it on the next two arguments. fun test(f: fun(Int, Int) -\u0026gt; Int, a: Int, b: Int): Int { return f(a, b); } // The function to pass to `test` fun add(a: Int, b: Int): Int = a + b; // Call `test` with our other function! println(test(add, 2, 3)); Output: 5 Templates # Functions may also take template parameters:\nfun first\u0026lt;A, B\u0026gt;(a: (A, B)): A = a.0; fun second\u0026lt;A, B\u0026gt;(a: (A, B)): B = a.1; println(first\u0026lt;Int, Float\u0026gt;((2, 3.0))); println(second\u0026lt;Int, Float\u0026gt;((2, 3.0))); Output: 2 3 ","date":"9 September 2024","externalUrl":null,"permalink":"/sage-website/docs/functions/","section":"Documentation","summary":"","title":"Functions","type":"docs"},{"content":" About the typesystem: Sage\u0026rsquo;s type system is based on parameterized algebraic data types. This gives Sage a much more expressive set of primitives than languages like C! Sage\u0026rsquo;s type system is built on structural type equality, meaning that two types are equal if they have the same structure. This allows for more flexible type definitions, and makes it easier to work with complex data structures.\nPrimitive Types # The following are the primitive types in Sage:\nInt: an integer, the word size of the target architecture. If you\u0026rsquo;re compiling to a 64-bit target, Int is 64 bits. Cell: a raw word-sized value, used for reinterpreting memory. To reinterpret a Float as an Int, you can cast it to a Cell first: 5.0 as Cell as Int. Float: a floating point number, the word size of the target architecture. This is a double for 64-bit targets. Bool: a boolean value, either True or False. Char: a word-sized character. [T * N]: an array of N elements of type T. \u0026amp;T: an immutable pointer to a value of type T. \u0026amp;mut T: a mutable pointer to a value of type T. fun(T1, T2, ..., Tn) -\u0026gt; T: a function that takes arguments of types T1, T2, \u0026hellip;, Tn and returns a value of type T. Pointers # To get a pointer of a value, you can use the \u0026amp; operator. To get a mutable pointer, you can use the \u0026amp;mut operator.\nlet a = 5; let p: \u0026amp;Int = \u0026amp;a; let mut b = 6; let p2 = \u0026amp;mut b; println(*p); *p2 = 1000; println(*p2); Output: 5 1000 If you take a mutable reference of an immutable value, the compiler will throw an error.\nlet a = 5; let p: \u0026amp;mut Int = \u0026amp;mut a; Error: 2 ‚îÇ let p: \u0026amp;mut Int = \u0026amp;mut a; LIR error: invalid refer expression \u0026amp;mut a Algebraic Data Types # Sage supports algebraic data types, which are a way of defining complex data structures. These types are defined using the type, struct, and enum keywords, and can be parameterized with other types.\nStructs # Structs are a way of defining a collection of named fields. They are defined using the struct keyword.\nstruct Point { x: Int, y: Int, } let p: Point = { x=5, y=6 }; println(p); Output: {x=5, y=6} Enums # Enums are a way of defining a type that can be one of several variants. They are defined using the enum keyword.\nenum Option\u0026lt;T\u0026gt; { Some(T), Nothing, } let o = Option\u0026lt;Int\u0026gt; of Some(5); match o { of Some(val) =\u0026gt; println(\u0026#34;there is a value: \u0026#34;, val), of Nothing =\u0026gt; println(\u0026#34;there is no value\u0026#34;) } Output: there is a value: 5 Type Aliases # Type aliases are a way of defining a new name for an existing type. They are defined using the type keyword.\ntype Point = { x: Int, y: Int }; let p: Point = { x=5, y=6 }; println(p); Output: {x=5, y=6} Type Parameters # Types can be parameterized with other types. This allows for more flexible type definitions.\ntype Pair\u0026lt;T, U\u0026gt; = { first: T, second: U }; let p: Pair\u0026lt;Int, Char\u0026gt; = { first=5, second=\u0026#39;a\u0026#39; }; println(p); Output: {first=5, second=\u0026lsquo;a\u0026rsquo;} Const-Generics # Sage supports const-generics, which are a way of defining types that are parameterized by constants.\nstruct Matrix\u0026lt;Elem, const Rows: Int, const Cols: Int\u0026gt; { data: [[Elem * Cols] * Rows], } let m: Matrix\u0026lt;Int, 2, 2\u0026gt; = { data=[[1, 2], [3, 4]] }; println(m); Output: {data=[[1, 2], [3, 4]]} ","date":"9 September 2024","externalUrl":null,"permalink":"/sage-website/docs/data-types/","section":"Documentation","summary":"","title":"Data Types","type":"docs"},{"content":" Constants # Constants are immutable values that are defined at compile time. They are useful for defining compile time parameters, such as the size of an array.\nconst A = 5; println(A); Output: 5 You can use constants in type definitions as well.\nconst A = 5; type FiveLong\u0026lt;T\u0026gt; = [T * A]; let a: FiveLong\u0026lt;Int\u0026gt; = [1, 2, 3, 4, 5]; println(a); Output: [1, 2, 3, 4, 5] For now, constants are limited to very simple expressions, but we plan to expand this in the future. Ideally, users should be able to run arbitrary Sage code at compile time to define constants.\n","date":"9 September 2024","externalUrl":null,"permalink":"/sage-website/docs/constants/","section":"Documentation","summary":"","title":"Constants","type":"docs"},{"content":" Let Bindings # Variables are bound in Sage using the let keyword. You can optionally include the type of the variable to be typechecked against.\n// Create a variable named a, with the value 5 let a = 5; let b = {x=5, y=6}; let c: (Int, Int, Int) = (1, 2, 3); // Optionally include the type println(a); println(b); println(c); Output: 5 {x=5, y=6} (1, 2, 3) Mutability # You can make a variable as mutable with the mut keyword. If you try to assign to a variable that isn\u0026rsquo;t mutable, the compiler will yell at you!\nlet mut a = 5; println(a); a = 6; println(a); Output: 5 6 Destructured Let Bindings # In many instances, users want to be able to decompose the attributes of structures or tuples into variables.\nlet (a, {mut x, y}) = (1, {x=5, y=6}); println(a, \u0026#34;, \u0026#34;, x, \u0026#34;, \u0026#34;, y); x = 999; println(a, \u0026#34;, \u0026#34;, x, \u0026#34;, \u0026#34;, y); Output: 1, 5, 6 1, 999, 6 Variables And Scope # Variables are not captured by functions \u0026ndash; functions mainly act as procedures. Additionally, variables may not be referenced before their definition.\nprintln(a); let a = 5; Error: 2 ‚îÇ println(a); LIR error: symbol a not defined ","date":"9 September 2024","externalUrl":null,"permalink":"/sage-website/docs/variables/","section":"Documentation","summary":"","title":"Variables And Mutability","type":"docs"},{"content":" Writing And Executing A Sage Program # Install Sage: First, head to the installation page to get Sage on your machine! Once you have Sage installed, you can start writing Sage code!\nBegin by creating a new folder for your Sage project:\n$ mkdir hello-world $ cd hello-world Create a Sage program with the .sg file extension:\n$ echo \u0026#39;println(\u0026#34;Hello world!\u0026#34;);\u0026#39; \u0026gt; main.sg Then, compile and run your program!\n$ # Compile and interpret the VM code $ sage main.sg $ # Compile and translate the VM code to C $ sage main.sg -tc $ gcc out.c -O3 -o main # Compile the generated C code CLI Interface # For more information about Sage\u0026rsquo;s CLI, you can run sage -h:\n$ sage -h ‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà `-. _.-\u0026#39; ‚ñà‚ñà‚ñà‚ñë‚ñë ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñë‚ñë‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñë‚ñë‚ñà‚ñà‚ñà \\ `, .\u0026#39;/.\u0026#39; ‚ñë‚ñë‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñë‚ñà‚ñà‚ñà ‚ñë‚ñà‚ñà‚ñà‚ñë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà \\`.`. :.-\u0026#39;.-= .-\u0026#39;/ ‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñà ‚ñà‚ñà‚ñà‚ñë‚ñë‚ñà‚ñà‚ñà ‚ñë‚ñà‚ñà‚ñà ‚ñë‚ñà‚ñà‚ñà‚ñë‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë `-.:/o .\u0026#39;-\u0026#39;/ .\u0026#39; ‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà ‚ñë‚ñë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà o\\o / ._/.\u0026#39; ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñà‚ñà‚ñà ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë \\| /o|\\`. ‚ñà‚ñà‚ñà ‚ñë‚ñà‚ñà‚ñà |\u0026#39;o `.`.\u0026#39;. ‚ñë‚ñë‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà `--\u0026#39; ‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë Usage: sage [OPTIONS] \u0026lt;INPUT\u0026gt; Arguments: \u0026lt;INPUT\u0026gt; The input file to compiler Options: -o, --output \u0026lt;OUTPUT\u0026gt; The file to write the output of the compiler to [default: out] -s \u0026lt;SOURCE_TYPE\u0026gt; The source language to compile [default: sage] [possible values: sage, low-ir, core-asm, std-asm, core-vm, std-vm] -t \u0026lt;TARGET_TYPE\u0026gt; The target language to compile to [default: run] [possible values: run, core-asm, std-asm, core-vm, std-vm, c] -c, --call-stack-size \u0026lt;CALL_STACK_SIZE\u0026gt; The number of cells allocated for the call stack [default: 8192] -l, --log-level \u0026lt;LOG_LEVEL\u0026gt; The log level to use [default: off] [possible values: error, warn, info, debug, trace, off] -d, --debug \u0026lt;DEBUG\u0026gt; The symbol to debug (if any exists). This will also enable debug logging -h, --help Print help (see more with \u0026#39;--help\u0026#39;) -V, --version Print version Now that you have Sage on your machine, let\u0026rsquo;s dive into the language itself and write some neat programs!\n","date":"9 September 2024","externalUrl":null,"permalink":"/sage-website/docs/getting-started/","section":"Documentation","summary":"","title":"Getting Started","type":"docs"},{"content":" Discord # Discord: Most of the Sage community hangs out on Discord! Join the Sage Discord server to chat with the developers and other users!\nGitHub # GitHub: All of Sage\u0026rsquo;s development is managed on GitHub! Sage is open source! You can find the source code on GitHub.\nContributing # To contribute to Sage, clone and fork the GitHub repository. Checkout a branch git checkout -b your-feature-or-bug-fix and make your changes. Then, push your branch to your fork and open a pull request!\nThe continuous integration system will run the tests and check your code for style. Once your PR is approved, it will be merged into the main branch.\nBug Reports # If you find a bug in Sage, please open an issue!\n","date":"8 September 2024","externalUrl":null,"permalink":"/sage-website/docs/community/","section":"Documentation","summary":"","title":"Community","type":"docs"},{"content":" Table Of Contents # Overview Community Code Examples And Syntax Learn More About The Author Overview # Sage is a small programming language with a unique blend of features from Rust and Python. It\u0026rsquo;s statically typed, portable, and easy-to-use.\nWhy Sage? The Sage programming language was created as an alternative to languages like C, but with a nicer type system and development experience. Users are able to print out modules, functions, types. enums are more powerful, and can be used for better error management. Immutability is by default, with enforced typechecking and mutability rules. Sage also includes a module system for organizing code. Sage can be used for anything from operating systems development, to web development.\nCommunity # Check out our community page to get in contact with other users and developers! Let us know if you have any thoughts or comments about the language!\nCode Examples And Syntax # Without further ado, let\u0026rsquo;s see what Sage\u0026rsquo;s syntax looks like!\nHello World! # Sage code is like Python \u0026ndash; you can just start writing without a main function!\nTo print something, just use print on whatever arguments you want!\nprintln(\u0026#34;Hello world!\u0026#34;); Output: Hello world! print also works on custom data structures.\nprintln(\u0026#34;Hello! \u0026#34;, {x = 5, y = 6, z = 7}, \u0026#34; \u0026#34;, [1, 2, 3, 4]); Output: Hello! {x=5, y=6, z=7} [1, 2, 3, 4] Functions # You can write functions in Sage using the fun keyword. Here\u0026rsquo;s an example of the gcd function implemented in Sage!\n// Calculate the greatest common divisor of two numbers // using Euclid\u0026#39;s algorithm fun gcd(a: Int, b: Int): Int { if b == 0 { return a; } return gcd(b, a % b); } println(gcd(12, 15)); Output: 3 Standard Library Imports # You can get started with the standard library by importing some modules!\n// Import some stuff! from std.fallible import Option, Result, panic; from std.collections import Vec, HashMap, List; from std.io import *; // Create a vector and push stuff onto it! let mut v = Vec.make\u0026lt;Int\u0026gt;(); v.push(1); v.push(2); v.push(3); v.print(); Output: [1, 2, 3] Structs And Methods # Here\u0026rsquo;s how we can define custom struct types, and imbue them with methods we can call!\n// Create a structure named Point, with members `x` and `y` struct Point { x: Int, y: Int } impl Point { // A method for creating a new point fun new(x: Int, y: Int): Point { return {x = x, y = y}; } // Shift this point by a given amount in the X // and Y directions fun translate(\u0026amp;mut self, dx: Int, dy: Int) { self.x += dx; self.y += dy; } } // Create a mutable point at (4, 5) let mut p = Point.new(4, 5); // Print the point println(p); // Translate the X by -5, and the Y by 10 p.translate(-5, 10); // Print the translated point println(p); Output: {x=4, y=5} {x=-1, y=15} Sum Types # Sage supports generic algebraic datatypes, and typechecks them with structural equality! This lets you define types linked-lists in a much more canonical way than most languages.\nenum List\u0026lt;Elem\u0026gt; { Cons { data: Elem, next: \u0026amp;List\u0026lt;Elem\u0026gt; }, Nil } let l = List\u0026lt;Int\u0026gt; of Cons { data=5, next=new List\u0026lt;Int\u0026gt; of Nil }; match l { of Cons {data, next} =\u0026gt; { println(\u0026#34;l is cons with data=\u0026#34;, data, \u0026#34; and next=\u0026#34;, next); }, of Nil =\u0026gt; { println(\u0026#34;Got nil\u0026#34;); } } Output: l is cons with data=5 and next=\u0026amp;(38999) Const-Generics # Sage\u0026rsquo;s typesystem is also equipped to handle types with const parameters. This can come in handy for many use-cases. For example, this feature allows you to typecheck matrix dimensions in matrix multiplications!\n// Define a constant sized matrix with a generic element type // and parameterized width and height. struct Matrix\u0026lt;T, const Rows: Int, const Cols: Int\u0026gt; { arr: [[T * Cols] * Rows] } // Add some methods to our matrix impl Matrix\u0026lt;T, Rows, Cols\u0026gt; { // Create a new matrix populated with initial values fun new(x: T): Matrix\u0026lt;T, Rows, Cols\u0026gt; { return {arr=[[x] * Cols] * Rows}; } // Get a value from a matrix fun get(\u0026amp;self, row: Int, col: Int): \u0026amp;T { return \u0026amp;self.arr[row][col]; } // Multiply with another matrix fun mul\u0026lt;const NewCols: Int\u0026gt;( \u0026amp;self, other: \u0026amp;Matrix\u0026lt;T, Cols, NewCols\u0026gt;, zero: T, add: fun(T, T) -\u0026gt; T, mul: fun(T, T) -\u0026gt; T ): Matrix\u0026lt;T, Rows, NewCols\u0026gt; { let mut result = Matrix.new\u0026lt;T, Rows, NewCols\u0026gt;(zero); // Perform the actual matrix multiplication on the rows and cols // This uses the naive algorithm for matrix multiplication for let mut j=0; j\u0026lt;NewCols; j+=1; { for let mut i=0; i\u0026lt;Rows; i+=1; { let mut sum = zero; for let mut k=0; k\u0026lt;Cols; k+=1; { sum = add(sum, mul(self.arr[i][k], other.arr[k][j])); } result.arr[i][j] = sum; } } result } } Virtual Machine Instruction Set # History: What makes Sage special is not its frontend, however, but its backend. The backend was originally born out of a SIMD-extended Brainf$%\u0026amp;@ compiler. Sage\u0026rsquo;s instruction set is tiny enough to port in an afternoon, but efficient enough to compile high level code efficiently. The virtual machine is a simple Turing-tape based architecture, not a stack or register based virtual machine. This is one of the contributing factors to Sage\u0026rsquo;s portability.\nInstruction C Equivalent while while (reg[0]) { if if (reg[0]) { else } else { end } set N_0, N_1, ..., N_X reg[0] = N_0; reg[1] = N_1; ... reg[x] = N_X; call funs[reg[0]](); ret return; load N memcpy(reg, tape_ptr, N * sizeof(cell)); store N memcpy(tape_ptr, reg, N * sizeof(cell)); move N tape_ptr += N; where reg[0].p = tape_ptr; deref push(tape_ptr); tape_ptr = *tape_ptr; refer tape_ptr = pop(); index N for (int i=0; i\u0026lt;N; i++) reg[i].p += tape_ptr-\u0026gt;i; offset O, N for (int i=0; i\u0026lt;N; i++) reg[i].p += O; swap N for (int i=0; i\u0026lt;N; i++) swap(reg + i, tape_ptr + i); add N for (int i=0; i\u0026lt;N; i++) reg[i].i += tape_ptr[i].i; sub N for (int i=0; i\u0026lt;N; i++) reg[i].i -= tape_ptr[i].i; mul N for (int i=0; i\u0026lt;N; i++) reg[i].i *= tape_ptr[i].i; div N for (int i=0; i\u0026lt;N; i++) reg[i].i /= tape_ptr[i].i; rem N for (int i=0; i\u0026lt;N; i++) reg[i].i %= tape_ptr[i].i; or N for (int i=0; i\u0026lt;N; i++) reg[i].i ||= tape_ptr[i].i; and N for (int i=0; i\u0026lt;N; i++) reg[i].i \u0026amp;\u0026amp;= tape_ptr[i].i; not N for (int i=0; i\u0026lt;N; i++) reg[i].i = !reg[i].i; bitand N for (int i=0; i\u0026lt;N; i++) reg[i].i \u0026amp;= tape_ptr[i].i; bitor N for (int i=0; i\u0026lt;N; i++) reg[i].i |= tape_ptr[i].i; bitxor N for (int i=0; i\u0026lt;N; i++) reg[i].i ^= tape_ptr[i].i; lsh N for (int i=0; i\u0026lt;N; i++) reg[i].i \u0026lt;\u0026lt;= tape_ptr[i].i; l-rsh N for (int i=0; i\u0026lt;N; i++) reg[i].i = (uint64_t)reg[i].i \u0026gt;\u0026gt; tape_ptr[i].i; a-rsh N for (int i=0; i\u0026lt;N; i++) reg[i].i \u0026gt;\u0026gt;= tape_ptr[i].i; gez N for (int i=0; i\u0026lt;N; i++) reg[i].i = reg[i].i \u0026gt;= 0; Learn More # Documentation: First, take a look at the docs! You can read my blog post (~20 minute read) about the programming language to learn more about the implementation!\nHere\u0026rsquo;s a 23 minute YouTube video that covers how compilers work, and delves into Sage!\nJoin the Discord server to chat about Sage!\nHow do I contribute? # If you want to contribute, you can open an issue or a pull request. Adding backends for other architectures is a great way to contribute! We also need a VSCode syntax highlighting extension!\nAbout The Author # I\u0026rsquo;m a computer science PhD student at the University of Tennessee, Knoxvilleüçä. Rust is my favorite language, and I\u0026rsquo;ve written many other compilers. This is the last project I started as a teenager, and I was the only author to touch any of the code up to version v0.0.2-alpha (12/25/2023)!\n","date":"8 September 2024","externalUrl":null,"permalink":"/sage-website/docs/about/","section":"Documentation","summary":"","title":"About The Sage Programming Language","type":"docs"},{"content":" Start here: read the Getting Started page! ","date":"8 September 2024","externalUrl":null,"permalink":"/sage-website/docs/","section":"Documentation","summary":"","title":"Documentation","type":"docs"},{"content":" Pre-installation: You\u0026rsquo;ll the Rust programming language to build the compiler from source. If you\u0026rsquo;re on Windows, then you\u0026rsquo;ll need to download and install the MSVC toolchain prior to building everything. Once you\u0026rsquo;ve installed Rust, and you can use the cargo package manager, run the following to install Sage.\nInstall With Cargo # $ cargo install --git https://github.com/adam-mcdaniel/sage Clone And Build # You can also download the compiler from GitHub manually and build it.\n$ git clone https://github.com/adam-mcdaniel/sage $ cd sage $ # Just build the compiler from source, don\u0026#39;t install it: $ cargo build --release # The `sage` exe will be in `target/release` $ # Install it from this github clone: $ cargo install -f --path . Post-Install # Once you\u0026rsquo;ve installed everything, you can get started with Sage by running the sage command! Use sage -h to see some basic help on the CLI!\nWhat next? Check out the documentation, and take a look at the compiler playground for some example programs! ","date":"8 September 2024","externalUrl":null,"permalink":"/sage-website/installs/install/","section":"Installs","summary":"","title":"Install The Sage Programming Language","type":"installs"},{"content":"","date":"8 September 2024","externalUrl":null,"permalink":"/sage-website/installs/","section":"Installs","summary":"","title":"Installs","type":"installs"},{"content":"Here\u0026rsquo;s a compiler playground to experiment with the Sage programming language in the web! Feel free to edit the code and run your own programs!\nClick the compile button to compile and run the code. This will show the output in the lower pane.\nTo change the example program, use the drop down at the top of the playground. You can choose from a variety of examples to see the program features. You can also view the internal stages of compilation with the dropdown next to the compile button.\n","date":"8 September 2024","externalUrl":null,"permalink":"/sage-website/playgrounds/playground/","section":"Playgrounds","summary":"","title":"Experiment With Sage In The Web","type":"playgrounds"},{"content":"","date":"8 September 2024","externalUrl":null,"permalink":"/sage-website/playgrounds/","section":"Playgrounds","summary":"","title":"Playgrounds","type":"playgrounds"},{"content":"","externalUrl":null,"permalink":"/sage-website/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/sage-website/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","externalUrl":null,"permalink":"/sage-website/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"}]