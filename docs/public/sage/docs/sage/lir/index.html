<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="LIR (Low Intermediate Representation) Module"><title>sage::lir - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceSerif4-Regular-46f98efaafac5295.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Regular-018c141bf0843ffd.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/FiraSans-Medium-8f9a781e4970d388.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Regular-562dcc5011b6de7d.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../static.files/SourceCodePro-Semibold-d899c5a5c4aeb14a.ttf.woff2"><link rel="stylesheet" href="../../static.files/normalize-76eba96aa4d2e634.css"><link rel="stylesheet" href="../../static.files/rustdoc-ac92e1bbe349e143.css"><meta name="rustdoc-vars" data-root-path="../../" data-static-root-path="../../static.files/" data-current-crate="sage" data-themes="" data-resource-suffix="" data-rustdoc-version="1.76.0 (07dca489a 2024-02-04)" data-channel="1.76.0" data-search-js="search-2b6ce74ff89ae146.js" data-settings-js="settings-4313503d2e1961c2.js" ><script src="../../static.files/storage-f2adc0d6ca4d09fb.js"></script><script defer src="../sidebar-items.js"></script><script defer src="../../static.files/main-305769736d49e732.js"></script><noscript><link rel="stylesheet" href="../../static.files/noscript-feafe1bb7466e4bd.css"></noscript><link rel="alternate icon" type="image/png" href="../../static.files/favicon-16x16-8b506e7a72182f1c.png"><link rel="alternate icon" type="image/png" href="../../static.files/favicon-32x32-422f7d1d52889060.png"><link rel="icon" type="image/svg+xml" href="../../static.files/favicon-2c020d218678b618.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button></nav><nav class="sidebar"><div class="sidebar-crate"><h2><a href="../../sage/index.html">sage</a><span class="version">0.1.0-alpha</span></h2></div><h2 class="location"><a href="#">Module lir</a></h2><div class="sidebar-elems"><section><ul class="block"><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#traits">Traits</a></li></ul></section><h2><a href="../index.html">In crate sage</a></h2></div></nav><div class="sidebar-resizer"></div>
    <main><div class="width-limiter"><nav class="sub"><form class="search-form"><span></span><div id="sidebar-button" tabindex="-1"><a href="../../sage/all.html" title="show sidebar"></a></div><input class="search-input" name="search" aria-label="Run search in the documentation" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" tabindex="-1"><a href="../../help.html" title="help">?</a></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../static.files/wheel-7b819b6101059cd0.svg"></a></div></form></nav><section id="main-content" class="content"><div class="main-heading"><h1>Module <a href="../index.html">sage</a>::<wbr><a class="mod" href="#">lir</a><button id="copy-path" title="Copy item path to clipboard"><img src="../../static.files/clipboard-7571035ce49a181d.svg" width="19" height="18" alt="Copy item path"></button></h1><span class="out-of-band"><a class="src" href="../../src/sage/lir/mod.rs.html#1-93">source</a> · <button id="toggle-all-docs" title="collapse all docs">[<span>&#x2212;</span>]</button></span></div><details class="toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="lir-low-intermediate-representation-module"><a href="#lir-low-intermediate-representation-module">LIR (Low Intermediate Representation) Module</a></h2>
<p>This module contains a decently sized typechecked intermediate representation for the virtual machine.
The LIR, unlike the VM and the assembly language, is <em>not</em> split into two variants: there is only one variant.
The LIR compiler will generate core assembly code <em>by default</em> for the LIR, but will revert to the standard
variant if unsupported instructions or types are encountered (such as floating point operations or float types).</p>
<h3 id="index"><a href="#index">Index</a></h3>
<ol>
<li><a href="./enum.Type.html">Types</a></li>
<li><a href="./enum.ConstExpr.html">Constants</a> and <a href="./enum.Expr.html">Expressions</a></li>
<li><a href="struct.CoreBuiltin.html">Core Builtins</a> and <a href="struct.StandardBuiltin.html">Standard Builtins</a></li>
<li><a href="./enum.Error.html">Compilation Errors</a></li>
</ol>
<h3 id="purpose"><a href="#purpose">Purpose</a></h3>
<p>The purpose of the LIR is to provide a powerful backend for the next stage of IR. Most of the heavy lifting
of the actual compilation process is done by this stage of the compiler: typechecking, constant folding,
compiling to assembly, dealing with the two variants of the virtual machine, and so on. The stages of IR
above this simply implement features like macros and tagged-unions: very simple things which map 1:1 with
generated LIR code.</p>
<h3 id="features"><a href="#features">Features</a></h3>
<ol>
<li>The Type System</li>
</ol>
<p>LIR’s type system is very good for compiling directly to assembly. LIR supports the following types:</p>
<ul>
<li>None (the void type)</li>
<li>Never (the type of an expression which never returns a value: such as a <code>return</code> expression)</li>
<li>Int (a signed integer)</li>
<li>Float (a floating point number)</li>
<li>Bool (a boolean value)</li>
<li>Char (a single character)</li>
<li>Cell (the most basic unit of memory)</li>
<li>Pointer (a pointer to another given type)</li>
<li>Array (an array with elements, with a constant size expression)</li>
<li>Proc (a procedure with a list of arguments and a return type)</li>
<li>Tuple (a tuple with a list of distinct types. this is the product type)</li>
<li>Struct (a tuple with named fields)</li>
<li>Union (a union of types. this is the sum type when combined with a tag)</li>
<li>Enum (an enumeration with a list of variants. this is like a C enum, not a Rust enum)</li>
<li>Let (a type which allows the user to bind a type under a given name in another type expression)</li>
</ul>
<p>The Let type is extremely powerful, allowing users to create recursive types <em>inline</em>: without
binding them to a name under a LetType expression. Additionally, Let types are checked for equality
<em>structurally</em>, and this also works for comparing recursive types. There are many examples of this in <code>tests/lir.rs</code>.</p>
<ol start="2">
<li>The Constant Folding</li>
</ol>
<p>LIR also provides constant expressions to allow the user to do as much as possible during compile time.
This also makes it simpler to do compile-time optimizations.</p>
<ol start="3">
<li>Expressions</li>
</ol>
<p>The expressions that LIR uses to represent the program are very simple, and very powerful.
Arrays are kept distinct from Pointers (unlike in C), and so expressions can return stack allocated arrays without a problem.
Arrays can also be indexed without a pointer to the array, and so on. LIR supports getting members of tuples, structs,
and unions, and also getting their references as well.</p>
<ol start="4">
<li>Compilation Process</li>
</ol>
<p>LIR is designed to be able to compile <em>as much as possible</em> to the core variant of the assembly language. As long as you don’t
use floating point operations or standard builtins (<code>alloc</code> and <code>free</code>), you can compile to the core variant. Recursive types,
<em>inlined</em> recursive types, mutually recursive types, recursive functions, and core builtins are all supported without a problem.
<strong>The LIR compiler will only use a standard instruction if it has to.</strong></p>
</div></details><h2 id="structs" class="section-header"><a href="#structs">Structs</a></h2><ul class="item-table"><li><div class="item-name"><a class="struct" href="struct.Add.html" title="struct sage::lir::Add">Add</a></div></li><li><div class="item-name"><a class="struct" href="struct.And.html" title="struct sage::lir::And">And</a></div><div class="desc docblock-short">A boolean “And” operation between two values.</div></li><li><div class="item-name"><a class="struct" href="struct.Assign.html" title="struct sage::lir::Assign">Assign</a></div><div class="desc docblock-short">An assignment operation. This is used to implement assignment operators like <code>+=</code>.</div></li><li><div class="item-name"><a class="struct" href="struct.BitwiseAnd.html" title="struct sage::lir::BitwiseAnd">BitwiseAnd</a></div><div class="desc docblock-short">A boolean “BitwiseAnd” operation between two values.</div></li><li><div class="item-name"><a class="struct" href="struct.BitwiseNand.html" title="struct sage::lir::BitwiseNand">BitwiseNand</a></div><div class="desc docblock-short">A boolean “BitwiseNand” operation between two values.</div></li><li><div class="item-name"><a class="struct" href="struct.BitwiseNor.html" title="struct sage::lir::BitwiseNor">BitwiseNor</a></div><div class="desc docblock-short">A boolean “BitwiseNor” operation between two values.</div></li><li><div class="item-name"><a class="struct" href="struct.BitwiseNot.html" title="struct sage::lir::BitwiseNot">BitwiseNot</a></div></li><li><div class="item-name"><a class="struct" href="struct.BitwiseOr.html" title="struct sage::lir::BitwiseOr">BitwiseOr</a></div><div class="desc docblock-short">A boolean “BitwiseOr” operation between two values.</div></li><li><div class="item-name"><a class="struct" href="struct.BitwiseXor.html" title="struct sage::lir::BitwiseXor">BitwiseXor</a></div><div class="desc docblock-short">A boolean “BitwiseXor” operation between two values.</div></li><li><div class="item-name"><a class="struct" href="struct.CoreBuiltin.html" title="struct sage::lir::CoreBuiltin">CoreBuiltin</a></div><div class="desc docblock-short">A builtin pseudo-procedure implemented in the core assembly variant.</div></li><li><div class="item-name"><a class="struct" href="struct.Data.html" title="struct sage::lir::Data">Data</a></div><div class="desc docblock-short">Get the Union data associated with a tagged union (EnumUnion).</div></li><li><div class="item-name"><a class="struct" href="struct.Delete.html" title="struct sage::lir::Delete">Delete</a></div></li><li><div class="item-name"><a class="struct" href="struct.Env.html" title="struct sage::lir::Env">Env</a></div><div class="desc docblock-short">An environment under which expressions and types are compiled and typechecked.
This is essentially the scope of an expression.</div></li><li><div class="item-name"><a class="struct" href="struct.FFIProcedure.html" title="struct sage::lir::FFIProcedure">FFIProcedure</a></div><div class="desc docblock-short">A typed procedure which calls a foreign function.
This is compiled down to a standard assembly <code>Call</code> instruction.
The label is the name of the foreign function. The types determine the
size of the cells for the arguments and return value.</div></li><li><div class="item-name"><a class="struct" href="struct.Get.html" title="struct sage::lir::Get">Get</a></div></li><li><div class="item-name"><a class="struct" href="struct.Negate.html" title="struct sage::lir::Negate">Negate</a></div></li><li><div class="item-name"><a class="struct" href="struct.New.html" title="struct sage::lir::New">New</a></div></li><li><div class="item-name"><a class="struct" href="struct.Not.html" title="struct sage::lir::Not">Not</a></div><div class="desc docblock-short">A boolean “Not” operation on a value.</div></li><li><div class="item-name"><a class="struct" href="struct.Or.html" title="struct sage::lir::Or">Or</a></div><div class="desc docblock-short">A boolean “Or” operation between two values.</div></li><li><div class="item-name"><a class="struct" href="struct.PolyProcedure.html" title="struct sage::lir::PolyProcedure">PolyProcedure</a></div><div class="desc docblock-short">A polymorphic procedure of LIR code which can be applied to a list of arguments with type arguments.
This is mono-morphed into a <code>Procedure</code> when it is called with a list of type arguments.
A procedure is compiled down to a label in the assembly code.</div></li><li><div class="item-name"><a class="struct" href="struct.Procedure.html" title="struct sage::lir::Procedure">Procedure</a></div><div class="desc docblock-short">A monomorphic procedure of LIR code which can be applied to a list of arguments.
A procedure is compiled down to a label in the assembly code.
The label is called with the <code>Call</code> instruction.</div></li><li><div class="item-name"><a class="struct" href="struct.StandardBuiltin.html" title="struct sage::lir::StandardBuiltin">StandardBuiltin</a></div><div class="desc docblock-short">A builtin pseudo-procedure implemented in the standard assembly variant.</div></li><li><div class="item-name"><a class="struct" href="struct.Tag.html" title="struct sage::lir::Tag">Tag</a></div><div class="desc docblock-short">Get the Enum value of the tag associated with a tagged union (EnumUnion).</div></li></ul><h2 id="enums" class="section-header"><a href="#enums">Enums</a></h2><ul class="item-table"><li><div class="item-name"><a class="enum" href="enum.Annotation.html" title="enum sage::lir::Annotation">Annotation</a></div><div class="desc docblock-short">An annotation for metadata about an LIR expression.
This is used for error reporting, debugging, optimization,
and for representing the LIR in a human-readable format.</div></li><li><div class="item-name"><a class="enum" href="enum.Arithmetic.html" title="enum sage::lir::Arithmetic">Arithmetic</a></div><div class="desc docblock-short">An arithmetic operation.</div></li><li><div class="item-name"><a class="enum" href="enum.Comparison.html" title="enum sage::lir::Comparison">Comparison</a></div><div class="desc docblock-short">A comparison operation between two values.</div></li><li><div class="item-name"><a class="enum" href="enum.ConstExpr.html" title="enum sage::lir::ConstExpr">ConstExpr</a></div><div class="desc docblock-short">A compiletime expression.</div></li><li><div class="item-name"><a class="enum" href="enum.Declaration.html" title="enum sage::lir::Declaration">Declaration</a></div><div class="desc docblock-short">A declaration of a variable, function, type, etc.</div></li><li><div class="item-name"><a class="enum" href="enum.Error.html" title="enum sage::lir::Error">Error</a></div><div class="desc docblock-short">An LIR compilation error.</div></li><li><div class="item-name"><a class="enum" href="enum.Expr.html" title="enum sage::lir::Expr">Expr</a></div><div class="desc docblock-short">TODO: Add variants for <code>LetProc</code>, <code>LetVar</code>, etc. to support multiple definitions.
This way, we don’t overflow the stack with several clones of the environment.
A runtime expression.</div></li><li><div class="item-name"><a class="enum" href="enum.Mutability.html" title="enum sage::lir::Mutability">Mutability</a></div><div class="desc docblock-short">Mutability of a pointer.
This is used to provide type safety for pointers.
A mutable pointer can be used to mutate the value it points to.
An immutable pointer can only be used to read the value it points to.
An <code>Any</code> pointer can be used to read or write the value it points to; this is
used to override pointer access protections for compiler-builtins.</div></li><li><div class="item-name"><a class="enum" href="enum.Pattern.html" title="enum sage::lir::Pattern">Pattern</a></div><div class="desc docblock-short">A pattern which can be matched against an expression.</div></li><li><div class="item-name"><a class="enum" href="enum.Put.html" title="enum sage::lir::Put">Put</a></div><div class="desc docblock-short">Print a value to a given output.</div></li><li><div class="item-name"><a class="enum" href="enum.Type.html" title="enum sage::lir::Type">Type</a></div><div class="desc docblock-short">The representation of a type in the LIR type system.</div></li></ul><h2 id="traits" class="section-header"><a href="#traits">Traits</a></h2><ul class="item-table"><li><div class="item-name"><a class="trait" href="trait.AssignOp.html" title="trait sage::lir::AssignOp">AssignOp</a></div><div class="desc docblock-short">A trait used to implemented an assignment operation.</div></li><li><div class="item-name"><a class="trait" href="trait.BinaryOp.html" title="trait sage::lir::BinaryOp">BinaryOp</a></div><div class="desc docblock-short">A trait used to implement a binary operation.</div></li><li><div class="item-name"><a class="trait" href="trait.Compile.html" title="trait sage::lir::Compile">Compile</a></div><div class="desc docblock-short">A trait which allows an LIR expression to be compiled to one of the
two variants of the assembly language.</div></li><li><div class="item-name"><a class="trait" href="trait.GetSize.html" title="trait sage::lir::GetSize">GetSize</a></div><div class="desc docblock-short">Get the size of something in memory (number of cells).</div></li><li><div class="item-name"><a class="trait" href="trait.GetType.html" title="trait sage::lir::GetType">GetType</a></div><div class="desc docblock-short">Get the type associated with a value under a given environment.</div></li><li><div class="item-name"><a class="trait" href="trait.Simplify.html" title="trait sage::lir::Simplify">Simplify</a></div><div class="desc docblock-short">Simplify an expression while maintaining structural equality.</div></li><li><div class="item-name"><a class="trait" href="trait.TernaryOp.html" title="trait sage::lir::TernaryOp">TernaryOp</a></div><div class="desc docblock-short">A trait used to implement a ternary operation.</div></li><li><div class="item-name"><a class="trait" href="trait.TypeCheck.html" title="trait sage::lir::TypeCheck">TypeCheck</a></div><div class="desc docblock-short">A trait used to enforce type checking.</div></li><li><div class="item-name"><a class="trait" href="trait.UnaryOp.html" title="trait sage::lir::UnaryOp">UnaryOp</a></div><div class="desc docblock-short">A trait used to implement a unary operation.</div></li></ul></section></div></main></body></html>